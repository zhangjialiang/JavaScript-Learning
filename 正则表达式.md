#正则表达式#
###分组与非捕获性分组###
在正则表达式中，将某部分用括号抱包起来就形成了分组。
```
re = /abc{2}/;//将匹配abcc
re = /(abc){2}/;//将匹配abcabc
//上面的分组都是捕获性分组
```
非捕获性分组是指不会将分组返回到匹配结果之后的存储中
```
re = /(abc){2}/;//将匹配abcabc
//上面的分组都是捕获性分组
str = "abcabc ###";
arr = re.exec(str);
alert(arr[1]);//abc
//非捕获性分组 (?:)
re = /(?:abc){2}/;
arr = re.exec(str);
alert(arr[1]);//undefined
```

###反向引用###
当包含分组的正则表达式进行过test,match,search这些方法之后，每个分组都被放在一个特殊的地方以备将来使用，这些存储是分组中的特殊值，我们称之为反向引用。
```
var exp = /(\w+)\s(\w+)/
var str = 'abc def'
exp.exec(str)
> ["abc def", "abc", "edf"]
RegExp.$1
> "abc"
```
如上所述，被括号包起的部分成为分组，在exec之后，分组匹配会保留在结果中，这是可以通过$1-$9访问它们，或者在正则表达式中通过\1,\2的形式引用它们：
```
var exp = /(\w+)\s(\1>)/
var str = 'abc abc>'
exp.exec(str)
> ["abc abc>", "abc", "abc>"]
```

###正向前瞻###
用来捕获出现在特定字符之前的字符,只有当字符后面跟着某个特定字符才去捕获它。与正向前瞻对应的有负向前瞻，它用匹配只有当字符后面不跟着某个特定字符时才去匹配它。
```
//正向前瞻
re = /([a-z]+(?=\d))/i;
str = "abc every1 abc";
alert(re.test(str));//true
alert(RegExp.$1);//every

re = /([a-z](?!\d))/;i
//将匹配后面不包含数字的字母,并且不会返回(?!\d)中的内容
```
###反向前瞻###
与正向前瞻功能相反，反向前瞻匹配的是前面的字符
```
表达式 "(?<=\d{4})\d+(?=\d{4})" 
在匹配 "1234567890123456" 时，
将匹配除了前4个数字和后4个数字之外的中间8个数字
ps：js做不到

```

###第二个参数###
* g （全文查找）
* i （忽略大小写）
* m （多行查找）

<div style="width:200px;height:100px;background-color:red"></div>